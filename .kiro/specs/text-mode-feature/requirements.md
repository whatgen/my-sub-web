# 文本模式功能需求

## 概述
在现有的"简单模式"和"进阶模式"基础上，添加第三种"文本模式"，允许用户直接输入订阅内容（文本），系统将内容上传到服务器生成可访问的订阅链接URL，并进行长期存储管理。

## 核心逻辑

### 正确的订阅链接生成流程
```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户输入订阅内容（订阅文本/配置内容）                    │
│    例如：vmess://xxxxx                                      │
│          ss://yyyyy                                         │
│                                                             │
│ 2. 点击"生成订阅链接"                                       │
│    ↓                                                        │
│ 3. 将内容上传到服务器                                       │
│    POST /upload { content: "base64编码的订阅内容" }        │
│    ↓                                                        │
│ 4. 服务器存储内容并返回URL                                  │
│    返回：https://example.com/sub/abc123                    │
│    ↓                                                        │
│ 5. 这个URL才是真正的订阅链接                                │
│    params.subLink = "https://example.com/sub/abc123"       │
│    ↓                                                        │
│ 6. 客户端访问这个URL                                        │
│    GET https://example.com/sub/abc123                      │
│    ↓                                                        │
│ 7. 服务器返回原始订阅内容                                   │
│    返回：vmess://xxxxx\nss://yyyyy                         │
└─────────────────────────────────────────────────────────────┘
```

### 错误 vs 正确理解对比

**❌ 错误理解（之前的实现）**：
- 用户输入：`vmess://xxxxx`
- 直接设置：`params.subLink = "vmess://xxxxx"`
- 问题：这不是一个URL，客户端无法访问

**✅ 正确理解（应该实现的）**：
- 用户输入：`vmess://xxxxx`
- 上传到服务器
- 获得URL：`https://example.com/sub/abc123`
- 设置：`params.subLink = "https://example.com/sub/abc123"`
- 客户端访问URL后获得：`vmess://xxxxx`

### 类比说明
这就像：
- ❌ 错误：把一本书的内容当作书的地址
- ✅ 正确：把书放到图书馆（服务器），然后得到图书馆地址和书架号（URL）

## 用户故事
作为用户，我希望能够：
1. 直接输入订阅内容（文本），系统自动上传并生成可访问的订阅链接URL
2. 为每个订阅设置标题和可选密码保护
3. 长期存储我的订阅内容和对应的订阅链接，除非手动删除
4. 通过列表查看、编辑和删除已保存的订阅
5. 对密码保护的订阅进行验证后才能查看或编辑

## 功能需求

### AC1: 添加文本模式标签页
- 在现有的"简单模式"和"进阶模式"标签页后添加"文本模式"标签页
- 标签页图标使用合适的 iconify 图标
- 切换到文本模式时，显示文本模式专用的输入界面

### AC2: 文本模式输入界面
- 提供标题输入框（必填）
- 提供订阅内容文本框（必填，支持多行）- 用户在此输入订阅配置内容
- 提供"是否设置密码"开关
- 当开关开启时，显示密码输入框（必填）
- 输入界面应该清晰易用

### AC3: 订阅内容存储
- 用户点击"保存"按钮后，将订阅内容存储到本地存储（localStorage）
- 存储内容包括：标题、订阅内容文本、生成的订阅链接URL（如果已生成）、是否有密码、加密后的密码（如果设置）
- 存储应该是持久化的，刷新页面后数据不丢失
- 每个订阅应该有唯一标识符（ID）

### AC4: 订阅列表展示
- 在文本模式界面中提供下拉框或折叠面板展示已保存的订阅列表
- 列表显示每个订阅的标题
- 对于有密码保护的订阅，显示锁定图标标识

### AC5: 查看和编辑功能
- 用户可以从列表中选择一个订阅进行查看或编辑
- 如果订阅有密码保护，需要先输入密码验证
- 密码验证通过后，将订阅内容加载到输入框中
- 用户可以修改标题、订阅内容和密码设置
- 提供"更新"按钮保存修改

### AC6: 删除功能
- 每个列表项提供删除按钮
- 点击删除按钮时，显示确认对话框
- 确认后从本地存储中删除该订阅链接

### AC7: 生成订阅链接功能
- 在文本模式下，点击"生成订阅链接"按钮时：
  - 获取当前输入框中的订阅内容（或已选择订阅的内容）
  - 将订阅内容上传到服务器（使用类似短链接服务的API）
  - 服务器返回一个可访问的URL
  - 这个URL才是真正的订阅链接，设置到 `params.subLink`
  - 将订阅链接URL复制到剪贴板
  - 如果是已保存的订阅，更新其订阅链接URL字段
  - 显示成功提示
  
**技术实现**：
- 使用现有的短链接服务API或类似的内容托管服务
- 将订阅内容编码后上传
- 服务器返回可访问的URL
- 访问该URL时，服务器返回原始订阅内容

### AC8: 生成短链接功能
- 保留现有的"生成短链接"按钮功能
- 使用 `params.subLink` 的值生成短链接
- 生成的短链接复制到剪贴板

### AC9: 导入 Clash 功能
- 保留现有的"导入至 Clash"按钮功能
- 使用 `params.subLink` 或 `params.shortSubLink` 的值导入到 Clash

## 非功能需求

### NFR1: 数据安全
- 密码应该使用加密方式存储，不能明文保存
- 使用浏览器标准的加密 API 或成熟的加密库

### NFR2: 用户体验
- 界面应该与现有的简单模式和进阶模式保持一致的设计风格
- 操作应该有明确的反馈（成功/失败提示）
- 表单验证应该及时且友好

### NFR3: 性能
- 本地存储的读写操作应该高效
- 列表渲染应该流畅，即使有大量订阅链接

## 约束条件
- 使用 localStorage 作为本地存储方案（存储订阅内容和元数据）
- 需要服务器端支持内容上传和托管功能
- 可以复用现有的短链接服务API架构，或使用类似的内容托管服务
- 保持与现有代码风格和技术栈一致（React, NextUI, TypeScript）
- 不影响现有的简单模式和进阶模式功能

## 技术依赖
- **必需**：服务器端API支持上传和托管订阅内容
- **可选方案1**：扩展现有短链接服务，增加内容上传功能
- **可选方案2**：使用第三方内容托管服务（如GitHub Gist、Pastebin等）
- **可选方案3**：自建简单的内容托管服务

## 验收标准
- 所有功能需求（AC1-AC9）都已实现并通过测试
- 密码保护功能正常工作，无法绕过验证
- 数据持久化正常，刷新页面后数据不丢失
- 界面美观，与现有设计风格一致
- 无明显的性能问题或 bug
